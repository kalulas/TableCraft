using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reactive;
using System.Reactive.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Avalonia.Controls;
using Avalonia.Platform.Storage;
using FuzzySharp;
using Microsoft.Extensions.DependencyInjection;
using TableCraft.Core;
using TableCraft.Editor.Models;
using TableCraft.Editor.Services;
using ReactiveUI;
using Serilog;
using TableCraft.Editor.Extensions;
using Path = System.IO.Path;

namespace TableCraft.Editor.ViewModels;

public class MainWindowViewModel : ViewModelBase
{
    #region Fields

    private const string m_FilePickerWindowTitle = "Pick your table file";
    
    private static readonly FilePickerFileType m_DataSourceType = new("sources")
        {Patterns = Configuration.GetDataSourceExtensions().Select(extension => $"*.{extension}").ToArray()};
    
    private readonly ConfigFileRegistry m_ConfigFileRegistry;
    /// <summary>
    /// ConfigFileRelativeFilePath -> ConfigInfoViewModel, create on selected
    /// </summary>
    private readonly Dictionary<string, ConfigInfoViewModel> m_EditorRuntimeConfigInfo = new();
    /// <summary>
    /// ConfigFileRelativeFilePath -> score(generated by <see cref="UpdateSearchResultTableList"/>)
    /// </summary>
    private readonly Dictionary<string, int> m_TableListFuzzySearchScore = new();

    #endregion

    #region Propreties

    public string AssemblyVersion =>
        Assembly.GetEntryAssembly()?.GetName().Version?.ToString(3) ?? string.Empty;

    public string ListJsonFilename => Program.ListJsonFilename;

    public string ConfigHomePath => Program.Host.Services.GetRequiredService<AppSettings>().ConfigHomePath;

    public string JsonHomePath => Program.Host.Services.GetRequiredService<AppSettings>().JsonHomePath;

    private string m_ExportCodeUsage = string.Empty;

    /// <summary>
    /// ExportCodeUsage could be a single usage, or a usage group contains multiple usages
    /// </summary>
    public string ExportCodeUsage
    {
        get => m_ExportCodeUsage;
        set
        {
            this.RaiseAndSetIfChanged(ref m_ExportCodeUsage, value);
            this.RaisePropertyChanged(nameof(IsExportUsageSelected));
            this.RaisePropertyChanged(nameof(IsExportGroupSelected));
            
            OnExportCodeUsageChanged();
        }
    }

    private string m_ExportCodePath = string.Empty;
    
    public string ExportCodePath
    {
        get => m_ExportCodePath;
        set => this.RaiseAndSetIfChanged(ref m_ExportCodePath, value);
    }

    private string m_ExportGroupDesc = string.Empty;

    public string ExportGroupDesc
    {
        get => m_ExportGroupDesc;
        set => this.RaiseAndSetIfChanged(ref m_ExportGroupDesc, value);
    }

    public bool IsExportUsageSelected => !string.IsNullOrEmpty(ExportCodeUsage) && Configuration.IsDefinedUsage(ExportCodeUsage);
    
    public bool IsExportGroupSelected => !string.IsNullOrEmpty(ExportCodeUsage) && Configuration.IsDefinedUsageGroup(ExportCodeUsage);
    
    public bool SaveJsonOnGenerateCode { get; set; } = true;
    
    #region Tables and Selections

    public string TableListSearchText { get; set; } = string.Empty;
    
    public List<ConfigFileElementViewModel> TableList { get; } = new();
    
    public ObservableCollection<ConfigFileElementViewModel> SearchResultTableList { get; } = new();
    
    private ConfigFileElementViewModel? m_SelectedTable;

    /// <summary>
    /// For table list select use
    /// </summary>
    public ConfigFileElementViewModel? SelectedTable
    {
        get => m_SelectedTable;
        set => this.RaiseAndSetIfChanged(ref m_SelectedTable, value);
    }

    private ConfigInfoViewModel? m_SelectedConfigInfo;

    /// <summary>
    /// For attributes display use
    /// </summary>
    public ConfigInfoViewModel? SelectedConfigInfo
    {
        get => m_SelectedConfigInfo;
        private set => this.RaiseAndSetIfChanged(ref m_SelectedConfigInfo, value);
    }

    private ConfigAttributeDetailsViewModel? m_SelectedAttribute;

    public ConfigAttributeDetailsViewModel? SelectedAttribute
    {
        get => m_SelectedAttribute;
        set => this.RaiseAndSetIfChanged(ref m_SelectedAttribute, value);
    }

    #endregion

    /// <summary>
    /// Contains all export methods containing [UsageGroup ..., Usage ...]
    /// </summary>
    public static string[] ExportMethods
    {
        get
        {
            var groups = Configuration.ConfigUsageGroupNames;
            var usages = Configuration.ConfigUsageType;
            var methods = new string[groups.Length + usages.Length];
            Array.Copy(groups, methods, groups.Length);
            Array.Copy(usages, 0, methods, groups.Length, usages.Length);
            return methods;
        }
    }

    #endregion

    #region Commands

    public ReactiveCommand<Unit, Unit>? AddNewTableFileCommand { get; private set; }
    public ReactiveCommand<Unit, Unit>? SaveJsonFileCommand { get; private set; }
    public ReactiveCommand<Unit, Unit>? GenerateCodeCommand { get; private set; }
    public ReactiveCommand<Unit, Unit>? OpenPerforceWindowCommand { get; private set; }
    public ReactiveCommand<Unit, Unit>? OpenAboutWindowCommand { get; private set; }
    public Interaction<PerforceUserConfigViewModel, PerforceUserConfigViewModel?> ShowPerforceWindow { get; }
    public EventHandler<SelectionChangedEventArgs>? SelectedTableChangedEventHandler { get; private set; }
    public EventHandler<SelectionChangedEventArgs>? SelectedAttributeChangedEventHandler { get; private set; }
    public EventHandler<TextChangedEventArgs>? TableListSearchBoxTextChangedEventHandler { get; private set; }

    #endregion

    #region Private Methods

    public MainWindowViewModel(ConfigFileRegistry configFileRegistry)
    {
        m_ConfigFileRegistry = configFileRegistry;
        CreateSubViewModels(configFileRegistry);
        CreateCommands();
        ShowPerforceWindow = new Interaction<PerforceUserConfigViewModel, PerforceUserConfigViewModel?>();
    }

    private void CreateSubViewModels(ConfigFileRegistry configFileRegistry)
    {
        foreach (var tableElement in configFileRegistry.ReadTableElements())
        {
            var viewModel = new ConfigFileElementViewModel(tableElement);
            TableList.Add(viewModel);
            SearchResultTableList.Add(viewModel);
        }
    }

    private void CreateCommands()
    {
        AddNewTableFileCommand = ReactiveCommand.CreateFromTask(OnAddNewTableButtonClicked);
        AddNewTableFileCommand.ThrownExceptions.Subscribe(Program.HandleException);
        SaveJsonFileCommand = ReactiveCommand.CreateFromTask(OnSaveJsonFileButtonClicked);
        SaveJsonFileCommand.ThrownExceptions.Subscribe(Program.HandleException);
        GenerateCodeCommand = ReactiveCommand.CreateFromTask(OnGenerateCodeButtonClicked);
        GenerateCodeCommand.ThrownExceptions.Subscribe(Program.HandleException);
        OpenAboutWindowCommand = ReactiveCommand.CreateFromTask(OnOpenAboutWindowButtonClicked);
        OpenAboutWindowCommand.ThrownExceptions.Subscribe(Program.HandleException);
        OpenPerforceWindowCommand = ReactiveCommand.CreateFromTask(OnOpenPerforceWindowButtonClicked);
        OpenPerforceWindowCommand.ThrownExceptions.Subscribe(Program.HandleException);
        SelectedTableChangedEventHandler = OnSelectedTableChanged;
        SelectedAttributeChangedEventHandler = OnSelectedAttributeChanged;
        TableListSearchBoxTextChangedEventHandler = OnTableListSearchBoxTextChanged;
    }

    private void CancelSelectedAttribute()
    {
        SelectedAttribute = null;
    }

    private void UpdateSelectedExportCodeUsage()
    {
        var methods = ExportMethods;
        if (methods.Length == 0)
        {
            ExportCodeUsage = string.Empty;
            return;
        }

        ExportCodeUsage = methods[0]; // default selection
    }
    
    private async Task FlushTableListToRegistry()
    {
        var updatedTableList = TableList.Select(viewModel => viewModel.GetElement()).ToList();
        await m_ConfigFileRegistry.WriteTableElements(updatedTableList);
    }

    private async Task AddNewSelectedTableFile(string newTableFilePath)
    {
        var tableFileRelative = Path.GetRelativePath(ConfigHomePath, newTableFilePath);
        // don't share the same root
        if (string.Equals(tableFileRelative, newTableFilePath))
        {
            await MessageBoxManager.ShowStandardMessageBoxDialog(MessageBoxManager.ErrorTitle,
                $"Selected table file: '{newTableFilePath}' is not under config home path '{ConfigHomePath}'!");
            return;
        }
        
        if (TableList.Any(elementViewModel => elementViewModel.ConfigFileRelativePath == tableFileRelative))
        {
            await MessageBoxManager.ShowStandardMessageBoxDialog(MessageBoxManager.ErrorTitle,
                $"Table file already existed: '{tableFileRelative}'!");
            return;
        }
        
        // imported table file, without json file
        var tableElement = new ConfigFileElement(tableFileRelative, string.Empty);
        var createdTableViewModel = new ConfigFileElementViewModel(tableElement);

        var insertAt = TableList.Count;
        for (var index = 0; index < TableList.Count; index++)
        {
            var tableVm = TableList[index];
            if (string.Compare(tableVm.ConfigFileRelativePath, createdTableViewModel.ConfigFileRelativePath, 
                    StringComparison.Ordinal) <= 0) continue;
            insertAt = index;
            break;
        }
        
        TableList.Insert(insertAt, createdTableViewModel);
        SearchResultTableList.Add(createdTableViewModel);
        
        UpdateSearchResultTableList(TableListSearchText);
        
        // select new added
        SelectedTable = createdTableViewModel;
        
        // This is now triggered by `MainWindowViewModel.OnSelectedTableChanged`
        // SelectedConfigInfo = new ConfigInfoViewModel(createdTableViewModel.ConfigFilePath,
        //     createdTableViewModel.JsonFilePath, createdTableViewModel.GetConfigType());
        
        // write to local file, we make it async
        await FlushTableListToRegistry();
    }

    private void UpdateSelectedConfigInfoWithTable(ConfigFileElementViewModel? selectedTable)
    {
        if (selectedTable == null)
        {
            SelectedConfigInfo = null;
            return;
        }

        var identifier = selectedTable.ConfigFileRelativePath;
        var existed = m_EditorRuntimeConfigInfo.TryGetValue(identifier, out var createdConfigInfo);
        if (existed)
        {
            SelectedConfigInfo = createdConfigInfo;
            UpdateSelectedExportCodeUsage();
            return;
        }

        var configInfo = ConfigManager.singleton.CreateConfigInfo(selectedTable.ConfigFilePath,
            new []{selectedTable.JsonFilePath});
        if (configInfo == null)
        {
            Log.Error("Failed to create config info for '{identifier}' under '{HomePath}'",
                selectedTable.ConfigFileRelativePath,
                Program.Host.Services.GetRequiredService<AppSettings>().ConfigHomePath);
            SelectedConfigInfo = null;
            return;
        }
        
        var configInfoViewModel = new ConfigInfoViewModel(configInfo);
        m_EditorRuntimeConfigInfo.Add(identifier, configInfoViewModel);
        SelectedConfigInfo = configInfoViewModel;

        // reset selected attribute
        CancelSelectedAttribute();
        UpdateSelectedExportCodeUsage();
    }

    private void UpdateSelectedAttributeWithListItem(ConfigAttributeListItemViewModel? listItemViewModel)
    {
        if (listItemViewModel == null)
        {
            CancelSelectedAttribute();
            return;
        }

        var configInfo = listItemViewModel.GetAttributeInfo();
        SelectedAttribute = new ConfigAttributeDetailsViewModel(configInfo);
    }

    private void UpdateSearchResultTableList(string searchText)
    {
        if (SearchResultTableList.Count == 0)
        {
            return;
        }
        
        if (string.IsNullOrEmpty(searchText))
        {
            SearchResultTableList.Sort(ConfigFileElementViewModel.SortByRelativePath);
        }
        else
        {
            var tableNames = TableList.Select(viewModel => viewModel.ConfigFileRelativePath).ToArray();
            var results = Process.ExtractAll(searchText, tableNames);
            foreach (var result in results)
            {
                TableList[result.Index].TmpWeightedRatioScore = result.Score;
            }
        
            SearchResultTableList.Sort(ConfigFileElementViewModel.SortByScore);
        }
    }
    
    private async Task<bool> SaveJsonFileWithCurrentSelected()
    {
        if (m_SelectedConfigInfo == null || m_SelectedTable == null)
        {
            Log.Error("No selected config info, cannot save json file");
            return false;
        }

        // step1 save json file
        var configInfo = m_SelectedConfigInfo.GetConfigInfo();
        var jsonFileName = m_SelectedTable.GetTargetJsonFileName();
        var jsonFileFullPath = Path.Combine(JsonHomePath, jsonFileName);
        var success = ConfigManager.singleton.SaveConfigInfoWithDecorator(configInfo, jsonFileFullPath);
        if (!success)
        {
            Log.Error("Failed to save json file '{JsonFilePath}'", jsonFileFullPath);
            return false;
        }
        
        Log.Information("Saved json file '{JsonFilePath}'", jsonFileFullPath);
        
        // step2 update and save list.json
        m_SelectedTable.SetJsonFileRelativePath(jsonFileName);
        await FlushTableListToRegistry();
        Log.Information("Save table list to list.json finished");
        
        // step3 update 'json file found' status
        m_SelectedTable.NotifyJsonFileStatusChanged();
        return true;
    }

    #endregion

    #region Interactions

    private async Task OnAddNewTableButtonClicked()
    {
        var mainWindow = MessageBoxManager.GetMainWindow();
        if (mainWindow == null)
        {
            return;
        }
        
        var folder = await mainWindow.StorageProvider.TryGetFolderFromPathAsync(ConfigHomePath);
        var options = new FilePickerOpenOptions
        {
            Title = m_FilePickerWindowTitle,
            SuggestedStartLocation = folder,
            FileTypeFilter = new[] {m_DataSourceType},
            AllowMultiple = false
        };
        
        var results = await mainWindow.StorageProvider.OpenFilePickerAsync(options);
        if (results.Count != 0)
        {
            var selected = results[0];
            Log.Information("Selected table file from dialog: '{SelectedFile}'", selected.Path.LocalPath);
            // use Path.LocalPath instead of Path.AbsolutePath, for Path.LocalPath is a local operating-system presentation(windows: '\' separator)
            await AddNewSelectedTableFile(selected.Path.LocalPath);
        }
    }

    private void OnSelectedTableChanged(object? sender, SelectionChangedEventArgs e)
    {
        var selected = e.AddedItems.Count > 0 ? e.AddedItems[0] : null;
        var selectedTable = selected as ConfigFileElementViewModel;
        UpdateSelectedConfigInfoWithTable(selectedTable);
    }
    
    private void OnSelectedAttributeChanged(object? sender, SelectionChangedEventArgs e)
    {
        var selected = e.AddedItems.Count > 0 ? e.AddedItems[0] : null;
        var selectedListItem = selected as ConfigAttributeListItemViewModel;
        UpdateSelectedAttributeWithListItem(selectedListItem);
    }
    
    private void OnTableListSearchBoxTextChanged(object? sender, TextChangedEventArgs textChangedEventArgs)
    {
        if (sender is not TextBox textBox) { return; }
        UpdateSearchResultTableList(textBox.Text ?? string.Empty);
        // select with the highest score
        if (SearchResultTableList.Count != 0)
        {
            SelectedTable = SearchResultTableList[0];
        }
    }
    
    private void OnExportCodeUsageChanged()
    {
        var isUsageGroup = Configuration.IsDefinedUsageGroup(m_ExportCodeUsage);
        if (!isUsageGroup) // single usage
        {
            var appSettings = Program.Host.Services.GetRequiredService<Models.AppSettings>();
            var codeExportHomePath = appSettings.GetCodeExportPath(m_ExportCodeUsage);
            ExportCodePath = SelectedConfigInfo != null
                ? Path.Combine(codeExportHomePath, Configuration.GetTargetFilenameForUsage(m_ExportCodeUsage, SelectedConfigInfo.GetConfigInfo()))
                : codeExportHomePath;
        }
        else // usageGroup
        {
            var usages = Configuration.GetUsagesForGroup(m_ExportCodeUsage);
            var groupUsagesDesc = string.Join(", ", usages);
            ExportGroupDesc = groupUsagesDesc;
        }

    }

    private async Task OnOpenPerforceWindowButtonClicked()
    {
        var config = Program.Host.Services.GetRequiredService<IP4ConfigManager>().GetVersionControlConfig();
        var viewModel = new PerforceUserConfigViewModel(config);
        await ShowPerforceWindow.Handle(viewModel);

        if (config.IsReady())
        {
            Log.Information("Retry login with new perforce configuration {Config}", config);
            Core.IO.FileHelper.UnregisterFileEvent(Core.VersionControl.Perforce.Label);
            Core.IO.FileHelper.RegisterFileEvent(new Core.VersionControl.Perforce(config));
        }
    }
    
    private static async Task OnOpenAboutWindowButtonClicked()
    {
        const string newLine = "\r\n\r\n";
        await MessageBoxManager.ShowCustomMarkdownMessageBoxDialog("About",
            $"## Learn more about TableCraft.{newLine}" +
            $"view it on [github](https://github.com/kalulas/TableCraft) {newLine}" +
            $"Author: **boming.chen / kalulas** {newLine}");
    }
    
    private async Task OnSaveJsonFileButtonClicked()
    {
        var success = await SaveJsonFileWithCurrentSelected();
        // final step, show message box
        if (!success)
        {
            await MessageBoxManager.ShowStandardMessageBoxDialog(MessageBoxManager.ErrorTitle,
                "Failed to save json file, please refer to log for more details");
            return;
        }
        
        var jsonFileFullPath = Path.Combine(JsonHomePath, m_SelectedTable?.GetTargetJsonFileName() ?? string.Empty);
        await MessageBoxManager.ShowStandardMessageBoxDialog(MessageBoxManager.SuccessTitle,
            $"Json file saved: '{jsonFileFullPath}'");
    }
    
    private async Task OnGenerateCodeButtonClicked()
    {
        if (SaveJsonOnGenerateCode)
        {
            var saveJsonSuccess = await SaveJsonFileWithCurrentSelected();
            if (!saveJsonSuccess)
            {
                await MessageBoxManager.ShowStandardMessageBoxDialog(MessageBoxManager.ErrorTitle,
                    "Failed to save json file, please refer to log for more details");
                return;
            }
        }

        bool success;
        var configInfo = m_SelectedConfigInfo?.GetConfigInfo();
        var isUsageGroup = Configuration.IsDefinedUsageGroup(m_ExportCodeUsage);
        if (!isUsageGroup)
        {
            var appSettings = Program.Host.Services.GetRequiredService<Models.AppSettings>();
            var outputDir = appSettings.GetCodeExportPath(m_ExportCodeUsage);
            // if 'ConfigInfo' is null, GenerateCodeForUsage will handle it and return false
            success =
                await ConfigManager.singleton.GenerateCodeForUsage(m_ExportCodeUsage, configInfo, outputDir);
        }
        else
        {
            var appSettings = Program.Host.Services.GetRequiredService<Models.AppSettings>();
            var usages = Configuration.GetUsagesForGroup(m_ExportCodeUsage);
            var outputDirectories = new string[usages.Length];
            for (var i = 0; i < usages.Length; i++)
            {
                outputDirectories[i] = appSettings.GetCodeExportPath(usages[i]);
            }
            
            // generate multiple code files for each usage
            success = await ConfigManager.singleton.GenerateCodeForUsageGroup(m_ExportCodeUsage, configInfo, outputDirectories);
        }
        
        var popupTitle = success ? MessageBoxManager.SuccessTitle : MessageBoxManager.ErrorTitle;
        var popupMessage = success
            ? "Generation successfully finished"
            : "Generation failed, please refer to log for more details";
        await MessageBoxManager.ShowStandardMessageBoxDialog(popupTitle, popupMessage);
    }

    #endregion
}